个人表述来说
equals比较的是两个对象是否相等
== 比较的是两个对象的引用地址是否相等
基本类型比较的都是引用地址
equals来自于object中,在object里,equals的写法为this==obj的话,返回true;所以object的equals就是==
所以子类的equals之所以实现了比较字面量,都是因为他们重写了父类的equals方法;
拿String.equals举例
第一步就是效验是否==,如果引用地址一致,那么equals也是没有问题的
第二步判断object是否能完全转换成String,如果可以的话就把object转换为String
第三步判断obj  char的长度是否和转换成String的长度一致,如果一致
while长度循环
如果char的字符和String全部相等,返回true

这个就涉及到了hashCode,hashCode的作用就是获取哈希码,因为hashcode也是在Object里定义的,所以任何方法中都含有hashCode
但他只有在用到了有关hash的方法时才会起作用(扯的较远)
哈希码的作用说白了就是快速定位
打个比方,一本书,你想知道这本书里有没有某个字,你就要从头翻到尾,才能确定
但是假如你知道每一页都有什么字,并且你知道每个字对应的页码值,那么你就能快速的定位这个字的位置.
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！
散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。
一个数组,我给他初始定义长度为10,我要存1~10的数,定义他的值就是他的下坐标.那我要是想存11~20的呢,只需要给他下坐标设计成变量,如果参数大于10小于20,那么就-10就可以了,对应的就是1[11],2[12]以此类推
但是我要是想在10个空间里存0到20呢,只需要将上面两种处理方式结合起来就好了.但也面临一个问题,那就是一个下标下,对应了两个参数.这就是哈希值得碰撞.同一个下标,同一个引用地址,出现了两种不同的参数
所以这代表了什么,同一个hashcode对象不一定相等,但是如果两个对象== 那么他们的hashcode一定一致
hashcode散列表的方式大大的减少了equals的次数,先获取了索引,在对hashcode内部值进行equals,这是十分节省效率的
所以,要判断equals时,也要同时重写hashcode,保持散列表内容的一致,否则equals无效
